#!/bin/bash

#===============================================================================
# New Client Folder Generator - Enhanced Version
#===============================================================================
# Description: Creates organized folder structures for legal cases
# Author: Nick Wade
# Usage: ./NewClientFolder.sh
#===============================================================================

# Configuration
readonly BASE_DIR="$HOME/Documents/Projects/TestDirectory/Mwb-Work"
readonly SCRIPT_VERSION="2.0"

# Color codes for better output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly BLUE='\033[0;34m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

#===============================================================================
# Utility Functions
#===============================================================================

# Function to display colored output
print_colored() {
    local color=$1
    shift
    echo -e "${color}$*${NC}"
}

# Function to display error messages
error() {
    print_colored "$RED" "âŒ Error: $*" >&2
}

# Function to display success messages
success() {
    print_colored "$GREEN" "âœ… $*"
}

# Function to display info messages
info() {
    print_colored "$BLUE" "â„¹ï¸  $*"
}

# Function to display warning messages
warning() {
    print_colored "$YELLOW" "âš ï¸  $*"
}

# Function to convert text to Title Case
# Handles common legal abbreviations and proper nouns
to_title_case() {
    local input="$1"
    echo "$input" | awk '{
        for (i=1;i<=NF;i++) {
            # Handle common legal abbreviations that should stay uppercase
            if (toupper($i) ~ /^(DWI|DUI|BWI|PDR|COA|CCA|SCOTUS|FBI|DEA|ATF|IRS)$/) {
                $i = toupper($i)
            }
            # Handle Roman numerals
            else if ($i ~ /^[IVX]+$/) {
                $i = toupper($i)
            }
            # Handle ordinal numbers (1st, 2nd, etc.)
            else if ($i ~ /^[0-9]+(st|nd|rd|th)$/) {
                # Keep as is
            }
            # Standard title case
            else {
                $i = toupper(substr($i,1,1)) tolower(substr($i,2))
            }
        }
        print
    }'
}

# Function to trim whitespace from input
trim() {
    echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

# Function to sanitize path components (remove unsafe characters)
# Preserves alphanumeric characters, spaces, periods, underscores, and hyphens
sanitize_path_component() {
    echo "$1" | tr -cd '[:alnum:] ._-' | sed 's/[[:space:]]\+/ /g'
}

# Function to validate date format (MMDDYYYY)
validate_date() {
    local date="$1"
    
    # Check basic format
    if [[ ! "$date" =~ ^[0-9]{8}$ ]]; then
        return 1
    fi
    
    # Extract components
    local month="${date:0:2}"
    local day="${date:2:2}"
    local year="${date:4:4}"
    
    # Validate ranges
    if [[ $month -lt 1 || $month -gt 12 ]]; then
        return 1
    fi
    
    if [[ $day -lt 1 || $day -gt 31 ]]; then
        return 1
    fi
    
    # Basic validation for days in month (simplified)
    case $month in
        02) # February
            if [[ $day -gt 29 ]]; then
                return 1
            fi
            ;;
        04|06|09|11) # April, June, September, November
            if [[ $day -gt 30 ]]; then
                return 1
            fi
            ;;
    esac
    
    return 0
}

# Function to check if directory exists and handle conflicts
check_directory_conflict() {
    local dir_path="$1"
    
    if [[ -d "$dir_path" ]]; then
        warning "Directory already exists: $dir_path"
        echo "Options:"
        echo "1) Continue anyway (merge with existing)"
        echo "2) Cancel operation"
        echo "3) Choose different path"
        
        while true; do
            read -p "Enter choice [1-3]: " choice
            case "$choice" in
                1) return 0 ;;
                2) return 1 ;;
                3) return 2 ;;
                *) error "Invalid choice. Please enter 1, 2, or 3." ;;
            esac
        done
    fi
    return 0
}

# Function to create directory with error handling
create_directory() {
    local dir_path="$1"
    local description="${2:-directory}"
    
    if ! mkdir -p "$dir_path" 2>/dev/null; then
        error "Failed to create $description: $dir_path"
        error "Please check permissions and disk space."
        return 1
    fi
    
    return 0
}

#===============================================================================
# Input Collection Functions
#===============================================================================

# Function to get case type with validation
get_case_type() {
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘            Case Type             â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "1) State"
    echo "2) Federal"
    echo "3) Civil"
    echo "4) Postconviction"
    
    while true; do
        read -p "Enter corresponding number for case type [1-4]: " choice
        case "$choice" in
            1) CASE_TYPE="State"; break ;;
            2) CASE_TYPE="Federal"; break ;;
            3) CASE_TYPE="Civil"; break ;;
            4) CASE_TYPE="Postconviction"; break ;;
            *) error "Invalid selection. Please enter 1, 2, 3, or 4." ;;
        esac
    done
}

# Function to get postconviction subtype
get_postconviction_subtype() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘       Postconviction Type        â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "1) PDR"
    echo "2) Habeas"
    echo "3) Direct Appeal"
    echo "4) Expunction"
    echo "5) Nondisclosure"
    
    while true; do
        read -p "Enter number [1-5]: " choice
        case "$choice" in
            1) SUBTYPE="PDR"; break ;;
            2) SUBTYPE="Habeas"; break ;;
            3) SUBTYPE="Direct Appeal"; break ;;
            4) SUBTYPE="Expunction"; break ;;
            5) SUBTYPE="Nondisclosure"; break ;;
            *) error "Invalid selection. Please enter 1, 2, 3, 4, or 5." ;;
        esac
    done
}

# Function to get client name with validation
get_client_name() {
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘            Client Name           â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    while true; do
        read -p "Client's First Name: " first_raw
        FIRST_NAME=$(sanitize_path_component "$(to_title_case "$(trim "$first_raw")")")
        if [[ -n "$FIRST_NAME" && ${#FIRST_NAME} -ge 2 ]]; then
            break
        else
            error "First name must be at least 2 characters long."
        fi
    done
    
    while true; do
        read -p "Client's Last Name: " last_raw
        LAST_NAME=$(sanitize_path_component "$(to_title_case "$(trim "$last_raw")")")
        if [[ -n "$LAST_NAME" && ${#LAST_NAME} -ge 2 ]]; then
            break
        else
            error "Last name must be at least 2 characters long."
        fi
    done
    
    LAST_FIRST="${LAST_NAME}_${FIRST_NAME}"
    LAST="$LAST_NAME"
}

# Function to get court information
get_court_info() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘        Court Information         â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    # PDR cases don't require court information
    if [[ "$(printf '%s' "$SUBTYPE" | tr '[:lower:]' '[:upper:]')" = "PDR" ]]; then
        COURT=""
        return 0
    fi
    
    while true; do
        read -p "Court: " court_raw
        local court_trimmed=$(trim "$court_raw")
        if [[ -n "$court_trimmed" ]]; then
            if [[ "$CASE_TYPE" == "Federal" ]]; then
                COURT=$(sanitize_path_component "$(echo "$court_trimmed" | tr '[:lower:]' '[:upper:]')")
            else
                COURT=$(sanitize_path_component "$(to_title_case "$court_trimmed")")
            fi
            break
        else
            error "Court name cannot be empty. Please enter a valid court name."
        fi
    done
}

# Function to get case details
get_case_details() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘          Case Details            â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    # Get offense/cause of action
    while true; do
        read -p "Offense/Cause of Action: " offense_raw
        OFFENSE=$(sanitize_path_component "$(to_title_case "$(trim "$offense_raw")")")
        if [[ -n "$OFFENSE" ]]; then
            break
        else
            error "Offense/Cause of Action cannot be empty."
        fi
    done
    
    # Get cause number
    while true; do
        read -p "Cause number: " cause_no_raw
        CAUSE_NO=$(sanitize_path_component "$(trim "$cause_no_raw")")
        if [[ -n "$CAUSE_NO" ]]; then
            break
        else
            error "Cause number cannot be empty."
        fi
    done
    
    # Get incident date
    while true; do
        read -p "Date of the incident [MMDDYYYY]: " date_input
        if validate_date "$date_input"; then
            DATE="$date_input"
            break
        else
            error "Date must be valid MMDDYYYY format (e.g., 05312025)."
            info "Month: 01-12, Day: 01-31, Year: 4 digits"
        fi
    done
}

# Function to determine party automatically
determine_party() {
    if [[ "$CASE_TYPE" == "Civil" ]]; then
        PARTY="Defendant"
    elif [[ "$CASE_TYPE" == "Postconviction" ]]; then
        read -p "Is this case Ex parte? [y/N]: " is_ex_parte
        if [[ "$(printf '%s' "$is_ex_parte" | tr '[:upper:]' '[:lower:]')" == "y" ]]; then
            PARTY="Ex parte"
        else
            PARTY="State"
        fi
    else
        PARTY="State"
    fi
}

# Function to get county information for State and Civil cases
get_county_info() {
    if [[ "$CASE_TYPE" == "State" || "$CASE_TYPE" == "Civil" ]]; then
        while true; do
            read -p "Enter county: " county_raw
            COUNTY=$(sanitize_path_component "$(to_title_case "$(trim "$county_raw")")")
            if [[ -n "$COUNTY" ]]; then
                # Modify court name if not Harris County
                local county_lower=$(echo "$COUNTY" | tr '[:upper:]' '[:lower:]')
                if [[ "$county_lower" != "harris" ]]; then
                    COURT="$(echo "$COURT $COUNTY" | sed 's/^ *//')"
                fi
                break
            else
                error "County cannot be empty."
            fi
        done
    fi
}

#===============================================================================
# Path Generation Functions
#===============================================================================

# Function to build case path based on case type and details
build_case_path() {
    local subtype_lower=$(echo "${SUBTYPE:-none}" | tr '[:upper:]' '[:lower:]')
    
    if [[ "$CASE_TYPE" == "Postconviction" && "$subtype_lower" != "none" ]]; then
        BASE_PATH="$BASE_DIR/Postconviction/$SUBTYPE"
        if [[ "$SUBTYPE" == "Direct Appeal" ]]; then
            CASE_PATH="$BASE_PATH/${LAST_FIRST} Appeal ${COURT}/${OFFENSE} ${CAUSE_NO} ${DATE}"
        else
            CASE_PATH="$BASE_PATH/${LAST_FIRST} ${SUBTYPE} ${COURT}/${OFFENSE} ${CAUSE_NO} ${DATE}"
        fi
    elif [[ "$CASE_TYPE" == "Federal" ]]; then
        BASE_PATH="$BASE_DIR/Federal/${LAST_FIRST} ${COURT}"
        CASE_PATH="$BASE_PATH/${OFFENSE} ${CAUSE_NO} ${DATE}"
    elif [[ "$CASE_TYPE" == "Civil" ]]; then
        BASE_PATH="$BASE_DIR/Civil"
        CASE_PATH="$BASE_PATH/${LAST_FIRST} ${OFFENSE} ${DATE}"
    else
        BASE_PATH="$BASE_DIR/$CASE_TYPE"
        CASE_PATH="$BASE_PATH/${LAST_FIRST} ${COURT}/${OFFENSE} ${CAUSE_NO} ${DATE}"
    fi
}

#===============================================================================
# Edit Functions
#===============================================================================

# Consolidated function to handle field editing
edit_field() {
    local field_num="$1"
    
    case "$field_num" in
        1) # Client Name
            read -p "First Name: " first_raw
            FIRST_NAME=$(sanitize_path_component "$(to_title_case "$(trim "$first_raw")")")
            read -p "Last Name: " last_raw
            LAST_NAME=$(sanitize_path_component "$(to_title_case "$(trim "$last_raw")")")
            LAST_FIRST="${LAST_NAME}_${FIRST_NAME}"
            LAST="$LAST_NAME"
            ;;
        2) # Case Type
            get_case_type
            ;;
        3) # Subtype
            get_postconviction_subtype
            ;;
        4) # Court
            read -p "New Court: " court_raw
            local court_trimmed=$(trim "$court_raw")
            if [[ "$CASE_TYPE" == "Federal" ]]; then
                COURT=$(sanitize_path_component "$(echo "$court_trimmed" | tr '[:lower:]' '[:upper:]')")
            else
                COURT=$(sanitize_path_component "$(to_title_case "$court_trimmed")")
            fi
            ;;
        5) # County
            read -p "New County: " county_raw
            COUNTY=$(sanitize_path_component "$(to_title_case "$(trim "$county_raw")")")
            ;;
        6) # Party
            read -p "Party: " PARTY
            ;;
        7) # Offense
            read -p "Offense: " offense_raw
            OFFENSE=$(sanitize_path_component "$(to_title_case "$(trim "$offense_raw")")")
            ;;
        8) # Cause Number
            read -p "Cause Number: " cause_no_raw
            CAUSE_NO=$(sanitize_path_component "$(trim "$cause_no_raw")")
            ;;
        9) # Date
            while true; do
                read -p "Date of Incident [MMDDYYYY]: " date_input
                if validate_date "$date_input"; then
                    DATE="$date_input"
                    break
                else
                    error "Date must be valid MMDDYYYY format (e.g., 05312025)."
                fi
            done
            ;;
        *)
            error "Invalid field number"
            return 1
            ;;
    esac
    
    # Recalculate paths after editing
    build_case_path
}

# Function to handle the edit menu
edit_inputs() {
    while true; do
        echo ""
        echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
        echo "â•‘        Confirm/Edit Fields       â•‘"
        echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "1) Client Name:      $FIRST_NAME $LAST_NAME"
        echo "2) Case Type:        $CASE_TYPE"
        [[ -n "$SUBTYPE" ]] && echo "3) Subtype:          $SUBTYPE"
        [[ -n "$COURT" ]] && echo "4) Court:            $COURT"
        [[ -n "$COUNTY" ]] && echo "5) County:           $COUNTY"
        echo "6) Party:            $PARTY"
        echo "7) Offense:          $OFFENSE"
        echo "8) Cause Number:     $CAUSE_NO"
        echo "9) Incident Date:    $DATE"
        echo "10) Folder Path:     $CASE_PATH"
        echo "11) Continue and Create Folders"
        echo "0) Cancel Operation"
        
        read -p "Enter number to edit, or 11 to continue: " choice
        
        case "$choice" in
            1|2|3|4|5|6|7|8|9)
                edit_field "$choice"
                ;;
            10)
                info "Folder path is auto-generated. Rebuild by editing inputs above."
                ;;
            11)
                break
                ;;
            0)
                error "Operation cancelled."
                exit 1
                ;;
            *)
                error "Invalid choice"
                ;;
        esac
    done
}

#===============================================================================
# Folder Generation Functions
#===============================================================================

# Function to create core folder structure
create_core_structure() {
    local -a core_dirs=(
        "$CASE_PATH/${LAST_FIRST} Contract/Drafts"
        "$CASE_PATH/${LAST_FIRST} Pleadings & Filings/${LAST_FIRST} Briefs/Drafts"
        "$CASE_PATH/${LAST_FIRST} Pleadings & Filings/$PARTY Filings"
        "$CASE_PATH/${LAST_FIRST} Pleadings & Filings/${LAST} Motions/Drafts"
        "$CASE_PATH/${LAST_FIRST} Pleadings & Filings/${LAST} Notices/Drafts"
        "$CASE_PATH/${LAST_FIRST} Pleadings & Filings/${LAST} Orders"
        "$BASE_PATH/${LAST} Correspondence"
        "$CASE_PATH/${LAST} Research/Caselaw"
        "$CASE_PATH/${LAST} Research/Secondary Sources"
        "$CASE_PATH/${LAST} Research/Statutes"
    )
    
    # Add Record on Appeal for Postconviction cases (except PDR)
    if [[ "$CASE_TYPE" == "Postconviction" && "$(printf '%s' "$SUBTYPE" | tr '[:lower:]' '[:upper:]')" != "PDR" ]]; then
        core_dirs+=(
            "$CASE_PATH/${LAST_FIRST} Record on Appeal/${LAST} Clerks Record"
            "$CASE_PATH/${LAST_FIRST} Record on Appeal/${LAST} Reporters Record"
        )
    fi
    
    # Create all core directories
    for dir in "${core_dirs[@]}"; do
        if ! create_directory "$dir" "core directory"; then
            return 1
        fi
    done
    
    return 0
}

# Function to handle optional Discovery folder
add_discovery_folder() {
    # Skip discovery for postconviction cases
    if [[ "$CASE_TYPE" == "Postconviction" ]]; then
        return 0
    fi
    
    read -p "Add 'Discovery' folder? [y/N]: " add_discovery
    if [[ "$(printf '%s' "$add_discovery" | tr '[:upper:]' '[:lower:]')" == "y" ]]; then
        local discovery_path="$CASE_PATH/${LAST_FIRST} Discovery"
        if create_directory "$discovery_path" "Discovery folder"; then
            success "Discovery folder added!"
        else
            return 1
        fi
    else
        info "Discovery folder skipped."
    fi
    return 0
}

# Function to handle optional Investigation folder
add_investigation_folder() {
    read -p "Add 'Investigation' folder? [y/N]: " add_investigation
    if [[ "$(printf '%s' "$add_investigation" | tr '[:upper:]' '[:lower:]')" == "y" ]]; then
        if create_directory "$CASE_PATH/${LAST_FIRST} Investigation" "Investigation folder"; then
            success "Investigation folder added!"
        else
            return 1
        fi
    else
        info "Investigation folder skipped."
    fi
    return 0
}

# Function to handle Client Documents folder and subfolders (with batch selection)
add_client_documents_folder() {
    read -p "Add 'Client Documents' folder? [y/N]: " add_client_docs
    if [[ "$(printf '%s' "$add_client_docs" | tr '[:upper:]' '[:lower:]')" != "y" ]]; then
        info "Client Documents folder skipped."
        return 0
    fi

    local client_docs_path="$CASE_PATH/${LAST_FIRST} Client Documents"
    if ! create_directory "$client_docs_path" "Client Documents folder"; then
        return 1
    fi

    success "Client Documents folder added!"

    # Display options with numbers
    local -a options=(
        "$LAST Civil Litigation"
        "$LAST Criminal History"
        "$LAST Education Records"
        "$LAST Emails"
        "$LAST Employment Records"
        "$LAST Letters of Support"
        "$LAST Mental Health Records"
        "$LAST Notes"
        "$LAST Photos"
        "$LAST Prior Court Records"
        "$LAST Rehab Records"
        "$LAST Screenshots"
        "$LAST Timeline of Events"
        "$LAST Warrants"
    )
    echo "Select Client Document subfolders to add (space-separated numbers, or 0 to finish):"
    for i in "${!options[@]}"; do
        printf "%2d) %s\n" $((i+1)) "${options[$i]}"
    done
    echo " 0) Done"

    # Batch selection loop
    while true; do
        read -p "Selection: " selection
        [[ -z "$selection" ]] && break
        for num in $selection; do
            [[ $num == 0 ]] && break 2
            if [[ $num -ge 1 && $num -le ${#options[@]} ]]; then
                opt="${options[$((num-1))]}"
            else
                continue
            fi
            [[ -z "$opt" ]] && continue
            if create_directory "$client_docs_path/$opt" "subfolder"; then
                success "$opt added!"

                # Create nested folders based on selection
                case "$opt" in
                    "$LAST Criminal History")
                        local -a crim_dirs=(
                            "$client_docs_path/$opt/$LAST Convictions/Felony"
                            "$client_docs_path/$opt/$LAST Convictions/Misdemeanor"
                            "$client_docs_path/$opt/$LAST Deferred Adjudication"
                            "$client_docs_path/$opt/$LAST Probation"
                            "$client_docs_path/$opt/$LAST Jail Records"
                        )
                        for dir in "${crim_dirs[@]}"; do
                            create_directory "$dir" "criminal history subfolder"
                        done
                        ;;
                    "$LAST Employment Records")
                        local -a emp_dirs=(
                            "$client_docs_path/$opt/Pay Stubs"
                            "$client_docs_path/$opt/Schedules or Time Cards"
                            "$client_docs_path/$opt/Tax forms"
                        )
                        for dir in "${emp_dirs[@]}"; do
                            create_directory "$dir" "employment records subfolder"
                        done
                        ;;
                    "$LAST Mental Health Records")
                        local -a mh_dirs=(
                            "$client_docs_path/$opt/Psych Evaluations"
                            "$client_docs_path/$opt/Verification of Mental Health Disorder"
                        )
                        for dir in "${mh_dirs[@]}"; do
                            create_directory "$dir" "mental health records subfolder"
                        done
                        ;;
                    "$LAST Prior Court Records")
                        local -a court_dirs=(
                            "$client_docs_path/$opt/$LAST Court Correspondence"
                            "$client_docs_path/$opt/$LAST Discovery"
                            "$client_docs_path/$opt/$LAST Exhibits/Defense"
                            "$client_docs_path/$opt/$LAST Exhibits/Govt"
                            "$client_docs_path/$opt/$LAST Indictment"
                            "$client_docs_path/$opt/$LAST Jury/$LAST Jury Charge"
                            "$client_docs_path/$opt/$LAST Limine 404"
                            "$client_docs_path/$opt/$LAST Mitigation"
                            "$client_docs_path/$opt/$LAST Motions/Defense"
                            "$client_docs_path/$opt/$LAST Motions/Govt"
                            "$client_docs_path/$opt/$LAST Other Govt Filings"
                            "$client_docs_path/$opt/$LAST Sentencing"
                            "$client_docs_path/$opt/$LAST Subpoenas/Defense"
                            "$client_docs_path/$opt/$LAST Subpoenas/Govt"
                        )
                        for dir in "${court_dirs[@]}"; do
                            create_directory "$dir" "prior court records subfolder"
                        done
                        ;;
                    "$LAST Rehab Records")
                        local -a rehab_dirs=(
                            "$client_docs_path/$opt/Attendance Logs"
                            "$client_docs_path/$opt/Proof of Completion"
                            "$client_docs_path/$opt/Staff Recommendations"
                        )
                        for dir in "${rehab_dirs[@]}"; do
                            create_directory "$dir" "rehab records subfolder"
                        done
                        ;;
                esac
            fi
        done
    done

    return 0
}

# Main function to generate folder structure
generate_structure() {
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘         Optional Folders        â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    # Create core structure
    info "Creating core folder structure..."
    if ! create_core_structure; then
        error "Failed to create core folder structure."
        return 1
    fi
    
    # Add optional folders
    add_investigation_folder || return 1
    add_client_documents_folder || return 1
    add_discovery_folder || return 1
    
    return 0
}

#===============================================================================
# Main Script Logic
#===============================================================================

# Function to display script header
show_header() {
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘            Legal Case Folder Generator v$SCRIPT_VERSION      â•‘"
    echo "â•‘                                                              â•‘"
    echo "â•‘  Creates organized folder structures for legal cases         â•‘"
    echo "â•‘  Supports: State, Federal, Civil, and Postconviction cases   â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
}

# Function to validate prerequisites
validate_prerequisites() {
    # Check if base directory exists or can be created
    if [[ ! -d "$BASE_DIR" ]]; then
        warning "Base directory doesn't exist: $BASE_DIR"
        read -p "Create base directory? [Y/n]: " create_base
        if [[ "$(printf '%s' "$create_base" | tr '[:upper:]' '[:lower:]')" != "n" ]]; then
            if ! create_directory "$BASE_DIR" "base directory"; then
                error "Cannot create base directory. Exiting."
                exit 1
            fi
            success "Base directory created: $BASE_DIR"
        else
            error "Base directory required. Exiting."
            exit 1
        fi
    fi
    
    # Check write permissions
    if [[ ! -w "$BASE_DIR" ]]; then
        error "No write permission for base directory: $BASE_DIR"
        exit 1
    fi
}

# Main function
main() {
    show_header
    validate_prerequisites
    
    # Collect input data
    get_case_type
    
    # Get subtype for Postconviction cases
    if [[ "$CASE_TYPE" == "Postconviction" ]]; then
        get_postconviction_subtype
    fi
    
    get_client_name
    get_court_info
    get_case_details
    determine_party
    get_county_info
    
    # Build initial case path
    build_case_path
    
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘        Folder Path Preview       â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "ğŸ“ $CASE_PATH"
    
    # Allow user to edit inputs
    edit_inputs
    
    # Check for directory conflicts
    case $(check_directory_conflict "$CASE_PATH") in
        1) # Cancel
            error "Operation cancelled due to directory conflict."
            exit 1
            ;;
        2) # Choose different path
            warning "Please restart the script to choose a different path."
            exit 1
            ;;
        0) # Continue
            ;;
    esac
    
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘          Setup Complete          â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    # Final confirmation
    read -p "Proceed with folder creation? [Y/n]: " confirm
    if [[ "$(printf '%s' "$confirm" | tr '[:upper:]' '[:lower:]')" != "n" ]]; then
        if generate_structure; then
            echo ""
            success "A new client folder has been created for $LAST_FIRST"
            echo ""
            echo "ğŸ“ Saved to: $CASE_PATH"
            echo ""
            info "Folder structure creation completed successfully!"

            # Display summary of created folders
            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘         Creation Summary         â•‘"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Case Type: $CASE_TYPE"
            [[ -n "$SUBTYPE" ]] && echo "Subtype: $SUBTYPE"
            echo "Client: $FIRST_NAME $LAST_NAME"
            echo "Offense: $OFFENSE"
            echo "Cause Number: $CAUSE_NO"
            echo "Date: $DATE"
            [[ -n "$COURT" ]] && echo "Court: $COURT"
            [[ -n "$COUNTY" ]] && echo "County: $COUNTY"
            echo "Party: $PARTY"
            echo ""
            info "You can now begin organizing your case materials in the created folders."
        else
            error "Folder creation failed. Please check the error messages above."
            exit 1
        fi
    else
        warning "Operation cancelled. No folders were created."
    fi
}

# Function to display usage information
show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

This script creates standardized folder structures for legal cases.

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version information
    
EXAMPLES:
    $0              Run interactively (recommended)
    
SUPPORTED CASE TYPES:
    â€¢ State         - State criminal cases
    â€¢ Federal       - Federal criminal cases  
    â€¢ Civil         - Civil litigation cases
    â€¢ Postconviction - Post-conviction relief cases
    
FOLDER STRUCTURE:
    The script creates a comprehensive folder structure including:
    â€¢ Contract and retainer documents
    â€¢ Pleadings and court filings
    â€¢ Research materials (caselaw, statutes, secondary sources)
    â€¢ Optional investigation materials
    â€¢ Optional client document organization
    â€¢ Optional discovery materials (non-postconviction cases)
    
REQUIREMENTS:
    â€¢ Bash shell
    â€¢ Write permissions to the target directory
    â€¢ Sufficient disk space for folder creation
    
For more information, see the script comments or contact the author.
EOF
}

# Function to show version information
show_version() {
    echo "Legal Case Folder Generator version $SCRIPT_VERSION"
    echo "Enhanced version with improved error handling and features"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            echo "Use -h or --help for usage information."
            exit 1
            ;;
    esac
    shift
done

# Execute main function
main

# Exit successfully
exit 0

#===============================================================================
# End of Script
#===============================================================================
